"""
Validation Logic (refactored)
Validation functions for various inputs and states
"""

import streamlit as st
from typing import Dict, Any, List, Optional
from frontend.web.utils.constants import (
    SESSION_KEY_CURRENT_MODEL,
    SESSION_KEY_EXECUTOR_READY,
    API_KEYS,
    PROVIDERS
)


def check_model_required() -> bool:
    """Validate model selection
    
    Returns:
        bool: True if model is selected, False otherwise
    """
    return bool(st.session_state.get(SESSION_KEY_CURRENT_MODEL))


def validate_session_state() -> Dict[str, Any]:
    """Validate session state
    
    Returns:
        Dict: Validation result
    """
    validation_result = {
        "valid": True,
        "errors": [],
        "warnings": []
    }
    
    # Check required session state
    required_keys = [
        SESSION_KEY_EXECUTOR_READY,
        SESSION_KEY_CURRENT_MODEL
    ]
    
    for key in required_keys:
        if key not in st.session_state:
            validation_result["errors"].append(f"Missing session state: {key}")
            validation_result["valid"] = False
    
    # Check executor ready state
    if not st.session_state.get(SESSION_KEY_EXECUTOR_READY, False):
        validation_result["warnings"].append("Executor not ready")
    
    return validation_result


def validate_user_input(user_input: str) -> Dict[str, Any]:
    """Validate user input
    
    Args:
        user_input: User input text
        
    Returns:
        Dict: Validation result
    """
    validation_result = {
        "valid": True,
        "errors": [],
        "cleaned_input": ""
    }
    
    if not user_input:
        validation_result["errors"].append("Empty input")
        validation_result["valid"] = False
        return validation_result
    
    # Clean input
    cleaned = user_input.strip()
    
    if not cleaned:
        validation_result["errors"].append("Input contains only whitespace")
        validation_result["valid"] = False
        return validation_result
    
    # Check length
    if len(cleaned) > 5000:
        validation_result["errors"].append("Input too long (max 5000 characters)")
        validation_result["valid"] = False
        return validation_result
    
    validation_result["cleaned_input"] = cleaned
    return validation_result


def validate_model_info(model_info: Dict[str, Any]) -> Dict[str, Any]:
    """Validate model info
    
    Args:
        model_info: Model info dictionary
        
    Returns:
        Dict: Validation result
    """
    validation_result = {
        "valid": True,
        "errors": []
    }
    
    if not isinstance(model_info, dict):
        validation_result["errors"].append("Model info must be a dictionary")
        validation_result["valid"] = False
        return validation_result
    
    # Check required fields
    required_fields = ["model_name", "provider", "display_name"]
    
    for field in required_fields:
        if field not in model_info:
            validation_result["errors"].append(f"Missing required field: {field}")
            validation_result["valid"] = False
        elif not model_info[field]:
            validation_result["errors"].append(f"Empty required field: {field}")
            validation_result["valid"] = False
    
    # Check provider (case insensitive)
    if "provider" in model_info:
        provider = model_info["provider"]
        # Compare case-insensitively
        provider_found = any(provider.lower() == p.lower() for p in PROVIDERS)
        if not provider_found:
            validation_result["errors"].append(f"Unknown provider: {provider}")
            validation_result["valid"] = False
    
    return validation_result


def validate_message_format(message: Dict[str, Any]) -> Dict[str, Any]:
    """Validate message format
    
    Args:
        message: Message dictionary
        
    Returns:
        Dict: Validation result
    """
    validation_result = {
        "valid": True,
        "errors": []
    }
    
    if not isinstance(message, dict):
        validation_result["errors"].append("Message must be a dictionary")
        validation_result["valid"] = False
        return validation_result
    
    # Check required fields
    required_fields = ["type", "content", "id"]
    
    for field in required_fields:
        if field not in message:
            validation_result["errors"].append(f"Missing required field: {field}")
            validation_result["valid"] = False
    
    # Check message type
    valid_types = ["user", "ai", "tool"]
    if "type" in message and message["type"] not in valid_types:
        validation_result["errors"].append(f"Invalid message type: {message['type']}")
        validation_result["valid"] = False
    
    return validation_result


def validate_terminal_entry(entry: Dict[str, Any]) -> Dict[str, Any]:
    """Validate terminal entry
    
    Args:
        entry: Terminal entry dictionary
        
    Returns:
        Dict: Validation result
    """
    validation_result = {
        "valid": True,
        "errors": []
    }
    
    if not isinstance(entry, dict):
        validation_result["errors"].append("Terminal entry must be a dictionary")
        validation_result["valid"] = False
        return validation_result
    
    # Check required fields
    required_fields = ["type", "content", "timestamp"]
    
    for field in required_fields:
        if field not in entry:
            validation_result["errors"].append(f"Missing required field: {field}")
            validation_result["valid"] = False
    
    # Check terminal entry type
    valid_types = ["command", "output"]
    if "type" in entry and entry["type"] not in valid_types:
        validation_result["errors"].append(f"Invalid terminal entry type: {entry['type']}")
        validation_result["valid"] = False
    
    return validation_result


def validate_file_path(file_path: str, required_extension: Optional[str] = None) -> Dict[str, Any]:
    """Validate file path
    
    Args:
        file_path: File path
        required_extension: Required extension (optional)
        
    Returns:
        Dict: Validation result
    """
    validation_result = {
        "valid": True,
        "errors": []
    }
    
    if not file_path:
        validation_result["errors"].append("Empty file path")
        validation_result["valid"] = False
        return validation_result
    
    # Check extension
    if required_extension:
        if not file_path.endswith(required_extension):
            validation_result["errors"].append(f"File must have {required_extension} extension")
            validation_result["valid"] = False
    
    # Check path safety
    if ".." in file_path:
        validation_result["errors"].append("Path traversal detected")
        validation_result["valid"] = False
    
    return validation_result


def is_safe_html_content(content: str) -> bool:
    """Check HTML content safety
    
    Args:
        content: HTML content
        
    Returns:
        bool: True if safe
    """
    # Check dangerous HTML tags
    dangerous_tags = ["<script", "<iframe", "<object", "<embed", "<link", "<meta"]
    
    content_lower = content.lower()
    
    for tag in dangerous_tags:
        if tag in content_lower:
            return False
    
    return True


def validate_workflow_execution_state() -> Dict[str, Any]:
    """Validate workflow execution state
    
    Returns:
        Dict: Validation result
    """
    validation_result = {
        "can_execute": True,
        "errors": []
    }
    
    # Check executor ready state
    if not st.session_state.get(SESSION_KEY_EXECUTOR_READY, False):
        validation_result["errors"].append("Executor not ready")
        validation_result["can_execute"] = False
    
    # Check currently running workflow
    if st.session_state.get("workflow_running", False):
        validation_result["errors"].append("Another workflow is already running")
        validation_result["can_execute"] = False
    
    # Check model selection
    if not st.session_state.get(SESSION_KEY_CURRENT_MODEL):
        validation_result["errors"].append("No model selected")
        validation_result["can_execute"] = False
    
    return validation_result
